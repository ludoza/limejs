<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: node.js</title>
    
    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
	<link type="text/css" rel="stylesheet" href="styles/sour.css">
</head>

<body>

<div id="main">
    
    <h1 class="page-title">Source: node.js</h1>
    
    


	
    <section>
        <article>
            <pre class="prettyprint source"><code><a name="line1"></a>goog.provide('lime.Node');<a name="line2"></a>
<a name="line3"></a>
<a name="line4"></a>
goog.require('goog.events.EventTarget');<a name="line5"></a>
goog.require('goog.math.Box');<a name="line6"></a>
goog.require('goog.math.Coordinate');<a name="line7"></a>
goog.require('goog.math.Size');<a name="line8"></a>
goog.require('goog.math.Vec2');<a name="line9"></a>
goog.require('lime');<a name="line10"></a>
goog.require('lime.DirtyObject');<a name="line11"></a>
<a name="line12"></a>
goog.require('lime.Renderer.CANVAS');<a name="line13"></a>
goog.require('lime.Renderer.DOM');<a name="line14"></a>
<a name="line15"></a>
<a name="line16"></a>
/**<a name="line17"></a>
 * Node. Abstract drawable object in lime.<a name="line18"></a>
 * @constructor<a name="line19"></a>
 * @implements lime.DirtyObject<a name="line20"></a>
 * @extends goog.events.EventTarget<a name="line21"></a>
 */<a name="line22"></a>
lime.Node = function() {<a name="line23"></a>
    goog.events.EventTarget.call(this);<a name="line24"></a>
<a name="line25"></a>
    this.children_ = [];<a name="line26"></a>
<a name="line27"></a>
    this.parent_ = null;<a name="line28"></a>
<a name="line29"></a>
    /** type {Object.&lt;number, number>} */<a name="line30"></a>
    this.transitionsAdd_ = {};<a name="line31"></a>
    this.transitionsActive_ = {};<a name="line32"></a>
    this.transitionsActiveSet_ = {};<a name="line33"></a>
    /** type {Object.&lt;number, number>} */<a name="line34"></a>
    this.transitionsClear_ = {};<a name="line35"></a>
<a name="line36"></a>
    /**<a name="line37"></a>
     * Allow translate3d and other css optimizations<a name="line38"></a>
     * @type {boolean}<a name="line39"></a>
     */<a name="line40"></a>
    this.allow3DCSSTransform_ = true;<a name="line41"></a>
<a name="line42"></a>
    /**<a name="line43"></a>
     * Node has been added to DOM tree<a name="line44"></a>
     * @type {boolean}<a name="line45"></a>
     */<a name="line46"></a>
    this.inTree_ = false;<a name="line47"></a>
<a name="line48"></a>
    this.director_ = null;<a name="line49"></a>
<a name="line50"></a>
    this.scene_ = null;<a name="line51"></a>
<a name="line52"></a>
    /**<a name="line53"></a>
     * Hash of active event handlers<a name="line54"></a>
     * @type {Object}<a name="line55"></a>
     * @private<a name="line56"></a>
     */<a name="line57"></a>
    this.eventHandlers_ = {};<a name="line58"></a>
<a name="line59"></a>
    this.setScale(1);<a name="line60"></a>
<a name="line61"></a>
    this.setPosition(0, 0);<a name="line62"></a>
<a name="line63"></a>
    this.setSize(0, 0);<a name="line64"></a>
<a name="line65"></a>
    this.quality_ = 1.0;<a name="line66"></a>
<a name="line67"></a>
    this.setAnchorPoint(0.5, 0.5);<a name="line68"></a>
<a name="line69"></a>
    this.setRotation(0);<a name="line70"></a>
<a name="line71"></a>
    this.setAutoResize(lime.AutoResize.NONE);<a name="line72"></a>
<a name="line73"></a>
    this.opacity_ = 1;<a name="line74"></a>
<a name="line75"></a>
    this.setMask(null);<a name="line76"></a>
<a name="line77"></a>
    this.setRenderer(this.supportedRenderers[0].getType());<a name="line78"></a>
<a name="line79"></a>
    this.setDirty(lime.Dirty.LAYOUT);<a name="line80"></a>
};<a name="line81"></a>
goog.inherits(lime.Node, goog.events.EventTarget);<a name="line82"></a>
<a name="line83"></a>
/**<a name="line84"></a>
 * Supported renderers for Node<a name="line85"></a>
 * @type {Array.&lt;lime.Renderer>}<a name="line86"></a>
 */<a name="line87"></a>
lime.Node.prototype.supportedRenderers = [<a name="line88"></a>
    lime.Renderer.DOM,<a name="line89"></a>
    lime.Renderer.CANVAS<a name="line90"></a>
];<a name="line91"></a>
<a name="line92"></a>
/**<a name="line93"></a>
 * Set renderer for the node. Renderer defines what lower<a name="line94"></a>
 * level technology will be used for drawing node on screen<a name="line95"></a>
 * @param {lime.Renderer} value Renderer object.<a name="line96"></a>
 * @return {lime.Node} Node itself.<a name="line97"></a>
 */<a name="line98"></a>
lime.Node.prototype.setRenderer = function(value) {<a name="line99"></a>
    if (!this.renderer || this.renderer.getType() != value) {<a name="line100"></a>
        var index = -1;<a name="line101"></a>
        for (var i = 0; i &lt; this.supportedRenderers.length; i++) {<a name="line102"></a>
            if (this.supportedRenderers[i].getType() == value) {<a name="line103"></a>
                index = i;<a name="line104"></a>
                break;<a name="line105"></a>
            }<a name="line106"></a>
        }<a name="line107"></a>
        if (index == -1) return this; //not supported<a name="line108"></a>
<a name="line109"></a>
        this.renderer = this.supportedRenderers[i];<a name="line110"></a>
        this.setDirty(lime.Dirty.LAYOUT);<a name="line111"></a>
        for (var i = 0, child; child = this.children_[i]; i++) {<a name="line112"></a>
            child.setRenderer(value);<a name="line113"></a>
        }<a name="line114"></a>
    }<a name="line115"></a>
    return this;<a name="line116"></a>
};<a name="line117"></a>
<a name="line118"></a>
/**<a name="line119"></a>
 * Does node require DOM element for drawing?<a name="line120"></a>
 * @return {boolean} True if DOM is required.<a name="line121"></a>
 */<a name="line122"></a>
lime.Node.prototype.needsDomElement = function() {<a name="line123"></a>
    return !(this.parent_ &&<a name="line124"></a>
        this.parent_.renderer.getType() == lime.Renderer.CANVAS);<a name="line125"></a>
};<a name="line126"></a>
<a name="line127"></a>
/**<a name="line128"></a>
 * Return deepest element in DOM tree that is used<a name="line129"></a>
 * for drawing the Node.<a name="line130"></a>
 * @return {Element} Deepest DOM element.<a name="line131"></a>
 */<a name="line132"></a>
lime.Node.prototype.getDeepestDomElement = function() {<a name="line133"></a>
    return this.getDeepestParentWithDom().domElement;<a name="line134"></a>
};<a name="line135"></a>
<a name="line136"></a>
/**<a name="line137"></a>
 * Return deepest parent node that requires DOM element<a name="line138"></a>
 * for drawing on screen.<a name="line139"></a>
 * @return {lime.Node} Deepest parent.<a name="line140"></a>
 */<a name="line141"></a>
lime.Node.prototype.getDeepestParentWithDom = function() {<a name="line142"></a>
    if (this.needsDomElement()) {<a name="line143"></a>
        this.updateDomElement();<a name="line144"></a>
        return this;<a name="line145"></a>
    } else {<a name="line146"></a>
        if (this.parent_)<a name="line147"></a>
            return this.parent_.getDeepestParentWithDom();<a name="line148"></a>
    }<a name="line149"></a>
    return null;<a name="line150"></a>
};<a name="line151"></a>
<a name="line152"></a>
/**<a name="line153"></a>
 * Return array of parent nodes until scene object<a name="line154"></a>
 * @private<a name="line155"></a>
 * @return {Array.&lt;lime.Node>} Array of parents.<a name="line156"></a>
 */<a name="line157"></a>
lime.Node.prototype.getParentStack_ = function() {<a name="line158"></a>
    if (!this.parent_ || this instanceof lime.Scene) return [];<a name="line159"></a>
    var r = this.parent_.children_.indexOf(this);<a name="line160"></a>
    var a = this.parent_.getParentStack_();<a name="line161"></a>
    a.push(r);<a name="line162"></a>
    return a;<a name="line163"></a>
};<a name="line164"></a>
<a name="line165"></a>
/**<a name="line166"></a>
 * Compare two node positions in the tree<a name="line167"></a>
 * @param {lime.Node} n1 First node.<a name="line168"></a>
 * @param {lime.Node} n2 Second node.<a name="line169"></a>
 * @return {number} Comparison result.<a name="line170"></a>
 */<a name="line171"></a>
lime.Node.compareNode = function(n1, n2) {<a name="line172"></a>
    if (n1 == n2) return 0;<a name="line173"></a>
<a name="line174"></a>
    var s1 = n1.getParentStack_();<a name="line175"></a>
    var s2 = n2.getParentStack_();<a name="line176"></a>
<a name="line177"></a>
    var i = 0;<a name="line178"></a>
    while (true) {<a name="line179"></a>
        if (s1.length &lt;= i) return 1;<a name="line180"></a>
        if (s2.length &lt;= i) return -1;<a name="line181"></a>
<a name="line182"></a>
        if (s1[i] == s2[i]) {<a name="line183"></a>
            i++;<a name="line184"></a>
        } else {<a name="line185"></a>
            return s1[i] > s2[i] ? -1 : 1;<a name="line186"></a>
        }<a name="line187"></a>
    }<a name="line188"></a>
};<a name="line189"></a>
<a name="line190"></a>
/**<a name="line191"></a>
 * @type {boolean}<a name="line192"></a>
 * @private<a name="line193"></a>
 * @override<a name="line194"></a>
 */<a name="line195"></a>
lime.Node.prototype.customEvent_ = false;<a name="line196"></a>
<a name="line197"></a>
/**<a name="line198"></a>
 * Return a bitmask of dirty values that need to be updated before next drawing<a name="line199"></a>
 * The bitmask parts are values of lime.Dirty enum<a name="line200"></a>
 * @return {number} Dirty propertiest bitmask.<a name="line201"></a>
 */<a name="line202"></a>
lime.Node.prototype.getDirty = function() {<a name="line203"></a>
    return this.dirty_;<a name="line204"></a>
};<a name="line205"></a>
<a name="line206"></a>
/**<a name="line207"></a>
 * Sets a dirty value true. This means that object needs that<a name="line208"></a>
 * kind of updates before next draw.<a name="line209"></a>
 * @param {number} value Values to be added to the bitmask.<a name="line210"></a>
 * @param {number=} opt_pass Pass number (0-1).<a name="line211"></a>
 * @param {boolean=} opt_nextframe Register for next frame.<a name="line212"></a>
 * @return {lime.Node} Node itself.<a name="line213"></a>
 */<a name="line214"></a>
lime.Node.prototype.setDirty = function(value, opt_pass, opt_nextframe) {<a name="line215"></a>
<a name="line216"></a>
    if (value && !this.dirty_) {<a name="line217"></a>
        lime.setObjectDirty(this, opt_pass, opt_nextframe);<a name="line218"></a>
    }<a name="line219"></a>
    var old = this.dirty_;<a name="line220"></a>
    this.dirty_ |= value;<a name="line221"></a>
<a name="line222"></a>
    if (value == lime.Dirty.LAYOUT) {<a name="line223"></a>
        for (var i = 0, child; child = this.children_[i]; i++) {<a name="line224"></a>
            if (child instanceof lime.Node)<a name="line225"></a>
                child.setDirty(lime.Dirty.LAYOUT);<a name="line226"></a>
        }<a name="line227"></a>
    }<a name="line228"></a>
    if (!goog.isDef(this.dirty_) || !value) {<a name="line229"></a>
        this.dirty_ = 0;<a name="line230"></a>
        lime.clearObjectDirty(this, opt_pass, opt_nextframe);<a name="line231"></a>
    }<a name="line232"></a>
    if (value && this.maskTarget_) {<a name="line233"></a>
        this.mSet = false;<a name="line234"></a>
        this.maskTarget_.setDirty(~0);<a name="line235"></a>
    }<a name="line236"></a>
<a name="line237"></a>
    return this;<a name="line238"></a>
};<a name="line239"></a>
<a name="line240"></a>
<a name="line241"></a>
/**<a name="line242"></a>
 * Returns scale vector for the element. 1,1 means no scale.<a name="line243"></a>
 * @return {goog.math.Vec2} scale vector.<a name="line244"></a>
 */<a name="line245"></a>
lime.Node.prototype.getScale = function() {<a name="line246"></a>
    return this.scale_;<a name="line247"></a>
};<a name="line248"></a>
/**<a name="line249"></a>
 * Sets new scale vector for element. This function also accepts<a name="line250"></a>
 * 2 numbers or 1 number that would be coverted to vector before use<a name="line251"></a>
 * @param {(goog.math.Vec2|number)} value New scale vector.<a name="line252"></a>
 * @param {number=} opt_y Optionaly set scale using x,y.<a name="line253"></a>
 * @return {lime.Node} Node itself.<a name="line254"></a>
 */<a name="line255"></a>
lime.Node.prototype.setScale = function(value, opt_y) {<a name="line256"></a>
    if (arguments.length == 1 && goog.isNumber(value)) {<a name="line257"></a>
        this.scale_ = new goog.math.Vec2(value, value);<a name="line258"></a>
    } else if (arguments.length == 2) {<a name="line259"></a>
        this.scale_ = new goog.math.Vec2(arguments[0], arguments[1]);<a name="line260"></a>
    } else {<a name="line261"></a>
        this.scale_ = value;<a name="line262"></a>
    }<a name="line263"></a>
    if (this.transitionsActive_[lime.Transition.SCALE]) return this;<a name="line264"></a>
    return this.setDirty(lime.Dirty.SCALE);<a name="line265"></a>
};<a name="line266"></a>
<a name="line267"></a>
/**<a name="line268"></a>
 * Returns element's position coordinate<a name="line269"></a>
 * @return {!goog.math.Coordinate} Current position coordinate.<a name="line270"></a>
 */<a name="line271"></a>
lime.Node.prototype.getPosition = function() {<a name="line272"></a>
    return this.position_;<a name="line273"></a>
};<a name="line274"></a>
<a name="line275"></a>
/**<a name="line276"></a>
 * Sets new position for element. Also accepts 2 numbers(x and y value)<a name="line277"></a>
 * @param {(goog.math.Coordinate|number)} value Position coordinate.<a name="line278"></a>
 * @param {number=} opt_y Optionaly set position using x,y.<a name="line279"></a>
 * @return {lime.Node} object itself.<a name="line280"></a>
 */<a name="line281"></a>
lime.Node.prototype.setPosition = function(value, opt_y) {<a name="line282"></a>
    if (arguments.length == 2) {<a name="line283"></a>
        this.position_ = new goog.math.Coordinate(arguments[0], arguments[1]);<a name="line284"></a>
    } else {<a name="line285"></a>
        this.position_ = value;<a name="line286"></a>
    }<a name="line287"></a>
    if (this.transitionsActive_[lime.Transition.POSITION]) return this;<a name="line288"></a>
    return this.setDirty(lime.Dirty.POSITION);<a name="line289"></a>
};<a name="line290"></a>
<a name="line291"></a>
/**<a name="line292"></a>
 * Returns element used as a mask for current element<a name="line293"></a>
 * @return {lime.Node} Mask node.<a name="line294"></a>
 */<a name="line295"></a>
lime.Node.prototype.getMask = function() {<a name="line296"></a>
    return this.mask_;<a name="line297"></a>
};<a name="line298"></a>
/**<a name="line299"></a>
 * Sets element as a mask for current element<a name="line300"></a>
 * @param {lime.Node} value Mask node.<a name="line301"></a>
 * @return {lime.Node} object itself.<a name="line302"></a>
 */<a name="line303"></a>
lime.Node.prototype.setMask = function(value) {<a name="line304"></a>
    if (value == this.mask_) return this;<a name="line305"></a>
<a name="line306"></a>
    if (this.mask_) {<a name="line307"></a>
        this.mask_.releaseDependencies();<a name="line308"></a>
        delete this.mask_.maskTarget_;<a name="line309"></a>
    }<a name="line310"></a>
<a name="line311"></a>
    this.mask_ = value;<a name="line312"></a>
<a name="line313"></a>
    if (this.mask_) {<a name="line314"></a>
        this.mask_.setupDependencies();<a name="line315"></a>
        this.mask_.maskTarget_ = this;<a name="line316"></a>
    }<a name="line317"></a>
<a name="line318"></a>
    return this.setDirty(lime.Dirty.CONTENT);<a name="line319"></a>
};<a name="line320"></a>
<a name="line321"></a>
/**<a name="line322"></a>
 * Returns anchor point for the element.<a name="line323"></a>
 * @return {goog.math.Vec2} Anchorpoint vector.<a name="line324"></a>
 */<a name="line325"></a>
lime.Node.prototype.getAnchorPoint = function() {<a name="line326"></a>
    return this.anchorPoint_;<a name="line327"></a>
};<a name="line328"></a>
<a name="line329"></a>
/**<a name="line330"></a>
 * Sets elements anchor point to new value. Anchor point is used<a name="line331"></a>
 * when positioning the element to position coordinate. [0,0] means<a name="line332"></a>
 * top left corner, [1,1] bottom right, [.5,.5] means that element<a name="line333"></a>
 * is position by the center. You can also pass in 2 numbers.<a name="line334"></a>
 * @param {(goog.math.Vec2|number)} value AnchorPoint vector.<a name="line335"></a>
 * @param {number=} opt_y Optionaly set anchorpoint with x,y.<a name="line336"></a>
 * @return {lime.Node} object itself.<a name="line337"></a>
 */<a name="line338"></a>
lime.Node.prototype.setAnchorPoint = function(value, opt_y) {<a name="line339"></a>
    if (arguments.length == 2) {<a name="line340"></a>
        this.anchorPoint_ = new goog.math.Vec2(arguments[0], arguments[1]);<a name="line341"></a>
    } else {<a name="line342"></a>
        this.anchorPoint_ = value;<a name="line343"></a>
    }<a name="line344"></a>
    return this.setDirty(lime.Dirty.POSITION);<a name="line345"></a>
};<a name="line346"></a>
<a name="line347"></a>
/**<a name="line348"></a>
 * Returns rotation angle for element in degrees<a name="line349"></a>
 * @return {number} Rotation angle.<a name="line350"></a>
 */<a name="line351"></a>
lime.Node.prototype.getRotation = function() {<a name="line352"></a>
    return (this.rotation_ = this.rotation_ % 360);<a name="line353"></a>
};<a name="line354"></a>
<a name="line355"></a>
/**<a name="line356"></a>
 * Rotates element to specific angle in degrees<a name="line357"></a>
 * @param {number} value New rotation angle.<a name="line358"></a>
 * @return {lime.Node} object itself.<a name="line359"></a>
 */<a name="line360"></a>
lime.Node.prototype.setRotation = function(value) {<a name="line361"></a>
<a name="line362"></a>
    this.rotation_ = value;<a name="line363"></a>
<a name="line364"></a>
    if (this.transitionsActive_[lime.Transition.ROTATION]) return this;<a name="line365"></a>
<a name="line366"></a>
    return this.setDirty(lime.Dirty.POSITION);<a name="line367"></a>
};<a name="line368"></a>
<a name="line369"></a>
<a name="line370"></a>
/**<a name="line371"></a>
 * Returns true if element currently not visible<a name="line372"></a>
 * @return {boolean} True if node is hidden.<a name="line373"></a>
 */<a name="line374"></a>
lime.Node.prototype.getHidden = function() {<a name="line375"></a>
    return this.hidden_;<a name="line376"></a>
};<a name="line377"></a>
/**<a name="line378"></a>
 * Sets if element is visible or not<a name="line379"></a>
 * @param {boolean} value Hide(true) or show(false).<a name="line380"></a>
 * @return {lime.Node} object itself.<a name="line381"></a>
 */<a name="line382"></a>
lime.Node.prototype.setHidden = function(value) {<a name="line383"></a>
    this.hidden_ = value;<a name="line384"></a>
    this.setDirty(lime.Dirty.VISIBILITY);<a name="line385"></a>
    this.autoHide_ = 0;<a name="line386"></a>
    return this;<a name="line387"></a>
};<a name="line388"></a>
<a name="line389"></a>
/**<a name="line390"></a>
 * Returns elements dimension<a name="line391"></a>
 * @return {goog.math.Size} Current element dimensions.<a name="line392"></a>
 */<a name="line393"></a>
lime.Node.prototype.getSize = function() {<a name="line394"></a>
    return this.size_;<a name="line395"></a>
};<a name="line396"></a>
<a name="line397"></a>
/**<a name="line398"></a>
 * Sets dimensions for element. This funciton also<a name="line399"></a>
 * accepts 2 numbers: width,height<a name="line400"></a>
 * @param {(goog.math.Size|number)} value Elements new size.<a name="line401"></a>
 * @param {number=} opt_height Optionaly use widht,height as parameter.<a name="line402"></a>
 * @return {lime.Node} object itself.<a name="line403"></a>
 */<a name="line404"></a>
lime.Node.prototype.setSize = function(value, opt_height) {<a name="line405"></a>
    var oldSize = this.size_,<a name="line406"></a>
        newval,<a name="line407"></a>
        scale;<a name="line408"></a>
    if (arguments.length == 2) {<a name="line409"></a>
        newval = new goog.math.Size(arguments[0], arguments[1]);<a name="line410"></a>
    } else {<a name="line411"></a>
        newval = value;<a name="line412"></a>
    }<a name="line413"></a>
    //todo:clear this mess<a name="line414"></a>
    var ap2 = this.getAnchorPoint();<a name="line415"></a>
    if (oldSize && this.children_.length) {<a name="line416"></a>
        for (var i = 0; i &lt; this.children_.length; i++) {<a name="line417"></a>
            var c = this.children_[i];<a name="line418"></a>
            if (c.getAutoResize) {<a name="line419"></a>
                var ar = c.getAutoResize();<a name="line420"></a>
                if (ar == lime.AutoResize.NONE) continue;<a name="line421"></a>
                var b = c.getBoundingBox();<a name="line422"></a>
                var fixed = oldSize.width;<a name="line423"></a>
                var c1 = b.left + ap2.x * oldSize.width;<a name="line424"></a>
                var c2 = b.right - b.left;<a name="line425"></a>
                var c3 = fixed - b.right - ap2.x * oldSize.width;<a name="line426"></a>
                if (ar & lime.AutoResize.LEFT) fixed -= c1;<a name="line427"></a>
                if (ar & lime.AutoResize.WIDTH) fixed -= c2;<a name="line428"></a>
                if (ar & lime.AutoResize.RIGHT) fixed -= c3;<a name="line429"></a>
                if (fixed != oldSize.width) {<a name="line430"></a>
                    scale = (newval.width - fixed) /<a name="line431"></a>
                        (oldSize.width - fixed);<a name="line432"></a>
                    if (ar & lime.AutoResize.LEFT) c1 *= scale;<a name="line433"></a>
                    if (ar & lime.AutoResize.WIDTH) c2 *= scale;<a name="line434"></a>
                }<a name="line435"></a>
                fixed = oldSize.height;<a name="line436"></a>
                var r1 = b.top + ap2.y * oldSize.height;<a name="line437"></a>
                var r2 = b.bottom - b.top;<a name="line438"></a>
                var r3 = fixed - b.bottom - ap2.y * oldSize.height;<a name="line439"></a>
                if (ar & lime.AutoResize.TOP) fixed -= r1;<a name="line440"></a>
                if (ar & lime.AutoResize.HEIGHT) fixed -= r2;<a name="line441"></a>
                if (ar & lime.AutoResize.BOTTOM) fixed -= r3;<a name="line442"></a>
                if (fixed != oldSize.height) {<a name="line443"></a>
                    scale = (newval.height - fixed) /<a name="line444"></a>
                        (oldSize.height - fixed);<a name="line445"></a>
                    if (ar & lime.AutoResize.TOP) r1 *= scale;<a name="line446"></a>
                    if (ar & lime.AutoResize.HEIGHT) r2 *= scale;<a name="line447"></a>
                }<a name="line448"></a>
<a name="line449"></a>
                var ap = c.getAnchorPoint();<a name="line450"></a>
                c.setSize(c2, r2);<a name="line451"></a>
                c.setPosition(c1 + ap.x * c2 - ap2.x * newval.width,<a name="line452"></a>
                    r1 + ap.y * r2 - ap2.y * newval.height);<a name="line453"></a>
            }<a name="line454"></a>
<a name="line455"></a>
        }<a name="line456"></a>
<a name="line457"></a>
    }<a name="line458"></a>
    this.size_ = newval;<a name="line459"></a>
    return this.setDirty(lime.Dirty.SCALE);<a name="line460"></a>
};<a name="line461"></a>
<a name="line462"></a>
/**<a name="line463"></a>
 * Returns elements quality value.<a name="line464"></a>
 * @return {number} Quality value.<a name="line465"></a>
 */<a name="line466"></a>
lime.Node.prototype.getQuality = function() {<a name="line467"></a>
    return this.quality_;<a name="line468"></a>
};<a name="line469"></a>
/**<a name="line470"></a>
 * Sets quality value used while drawing. Not all rendermodes can draw<a name="line471"></a>
 * more effectively on lower quality. 1.0 full quality, 0.5 half quality.<a name="line472"></a>
 * Setting this walue larger than 1.0 almost never does anything good.<a name="line473"></a>
 * @param {number} value New quality value.<a name="line474"></a>
 * @return {lime.Node} object itself.<a name="line475"></a>
 */<a name="line476"></a>
lime.Node.prototype.setQuality = function(value) {<a name="line477"></a>
    if (this.quality_ != value) {<a name="line478"></a>
        this.quality_ = value;<a name="line479"></a>
        this.setDirty(lime.Dirty.SCALE);<a name="line480"></a>
        this.calcRelativeQuality();<a name="line481"></a>
    }<a name="line482"></a>
    return this;<a name="line483"></a>
};<a name="line484"></a>
<a name="line485"></a>
/**<a name="line486"></a>
 * Return cumulative quality value relative to screen full quality.<a name="line487"></a>
 * @return {number} Quality value.<a name="line488"></a>
 */<a name="line489"></a>
lime.Node.prototype.getRelativeQuality = function() {<a name="line490"></a>
    if (!this.relativeQuality_)<a name="line491"></a>
        this.calcRelativeQuality();<a name="line492"></a>
<a name="line493"></a>
    return this.relativeQuality_;<a name="line494"></a>
}<a name="line495"></a>
<a name="line496"></a>
/**<a name="line497"></a>
 * Calculates relative quality change from the<a name="line498"></a>
 * parent objects quality<a name="line499"></a>
 */<a name="line500"></a>
lime.Node.prototype.calcRelativeQuality = function() {<a name="line501"></a>
    var rq = goog.isDef(this.relativeQuality_) ?<a name="line502"></a>
        this.relativeQuality_ : this.quality_;<a name="line503"></a>
<a name="line504"></a>
    if (this.parent_ && this.parent_.relativeQuality_)<a name="line505"></a>
        rq = this.quality_ * this.parent_.relativeQuality_;<a name="line506"></a>
<a name="line507"></a>
    if (rq != this.relativeQuality_) {<a name="line508"></a>
        this.relativeQuality_ = rq;<a name="line509"></a>
        for (var i = 0, child; child = this.children_[i]; i++) {<a name="line510"></a>
            if (child instanceof lime.Node)<a name="line511"></a>
                child.calcRelativeQuality();<a name="line512"></a>
        }<a name="line513"></a>
        this.setDirty(lime.Dirty.SCALE);<a name="line514"></a>
    }<a name="line515"></a>
};<a name="line516"></a>
<a name="line517"></a>
/**<a name="line518"></a>
 * Returns autoresize rules bitmask.<a name="line519"></a>
 * @return {number} Autoresize bitmask.<a name="line520"></a>
 */<a name="line521"></a>
lime.Node.prototype.getAutoResize = function() {<a name="line522"></a>
    return this.autoResize_;<a name="line523"></a>
};<a name="line524"></a>
/**<a name="line525"></a>
 * Sets new autoresixe rules. NOT IMPLEMENTED!<a name="line526"></a>
 * @param {number} value New autoresize bitmask.<a name="line527"></a>
 * @return {lime.Node} object itself.<a name="line528"></a>
 */<a name="line529"></a>
lime.Node.prototype.setAutoResize = function(value) {<a name="line530"></a>
    this.autoResize_ = value;<a name="line531"></a>
    return this.setDirty(lime.Dirty.ALL);<a name="line532"></a>
};<a name="line533"></a>
<a name="line534"></a>
/**<a name="line535"></a>
 * Sets css 3d transforms rule (for DOM renderer).<a name="line536"></a>
 * XXX: This hack is required to fix a mobile Safari rendering bug.<a name="line537"></a>
 * It should only be used on nodes that are affected by the bug!<a name="line538"></a>
 * 3D acceleration in css transforms is enabled by default and applied<a name="line539"></a>
 * for iOS and Playbook.<a name="line540"></a>
 *<a name="line541"></a>
 * @param {boolean} value allow(true) or disable(false).<a name="line542"></a>
 * @return {lime.Node} object itself.<a name="line543"></a>
 */<a name="line544"></a>
lime.Node.prototype.setAllow3DCSSTransforms = function(value) {<a name="line545"></a>
    this.allow3DCSSTransform_ = value;<a name="line546"></a>
    return this;<a name="line547"></a>
};<a name="line548"></a>
<a name="line549"></a>
/**<a name="line550"></a>
 * Returns css 3d transforms flag<a name="line551"></a>
 * @return {boolean}<a name="line552"></a>
 */<a name="line553"></a>
lime.Node.prototype.getCSS3DTransformsAllowed = function() {<a name="line554"></a>
    return this.allow3DCSSTransform_;<a name="line555"></a>
};<a name="line556"></a>
<a name="line557"></a>
/**<a name="line558"></a>
 * Convert screen coordinate to node coordinate space<a name="line559"></a>
 * @param {goog.math.Coordinate} coord Screen coordinate.<a name="line560"></a>
 * @return {goog.math.Coordinate} Local coordinate.<a name="line561"></a>
 */<a name="line562"></a>
lime.Node.prototype.screenToLocal = function(coord) {<a name="line563"></a>
    if (!this.inTree_) return coord;<a name="line564"></a>
    var newcoord = this.getParent().screenToLocal(coord);<a name="line565"></a>
<a name="line566"></a>
    return this.parentToLocal(newcoord);<a name="line567"></a>
};<a name="line568"></a>
<a name="line569"></a>
/**<a name="line570"></a>
 * Covert coordinate form parent node space to<a name="line571"></a>
 * current node space<a name="line572"></a>
 * @param {goog.math.Coordinate} coord Parent coordinate.<a name="line573"></a>
 * @return {goog.math.Coordinate} Local coordinate.<a name="line574"></a>
 */<a name="line575"></a>
lime.Node.prototype.parentToLocal = function(coord) {<a name="line576"></a>
    if (!this.getParent()) return null;<a name="line577"></a>
<a name="line578"></a>
    coord.x -= this.position_.x;<a name="line579"></a>
    coord.y -= this.position_.y;<a name="line580"></a>
<a name="line581"></a>
    coord.x /= this.scale_.x;<a name="line582"></a>
    coord.y /= this.scale_.y;<a name="line583"></a>
<a name="line584"></a>
    if (this.rotation_ != 0) {<a name="line585"></a>
        var c2 = coord.clone(),<a name="line586"></a>
            rot = this.rotation_ * Math.PI / 180,<a name="line587"></a>
            cos = Math.cos(rot),<a name="line588"></a>
            sin = Math.sin(rot);<a name="line589"></a>
        coord.x = cos * c2.x - sin * c2.y;<a name="line590"></a>
        coord.y = cos * c2.y + sin * c2.x;<a name="line591"></a>
    }<a name="line592"></a>
<a name="line593"></a>
    return coord;<a name="line594"></a>
};<a name="line595"></a>
<a name="line596"></a>
/**<a name="line597"></a>
 * Convert coordinate in node space to screen coordinate<a name="line598"></a>
 * @param {goog.math.Coordinate} coord Local coordinate.<a name="line599"></a>
 * @return {goog.math.Coordinate} Screen coordinate.<a name="line600"></a>
 */<a name="line601"></a>
lime.Node.prototype.localToScreen = function(coord) {<a name="line602"></a>
    if (!this.inTree_) return coord;<a name="line603"></a>
<a name="line604"></a>
    return this.getParent().localToScreen(this.localToParent(coord));<a name="line605"></a>
};<a name="line606"></a>
<a name="line607"></a>
/**<a name="line608"></a>
 * Convert coordinate from current node space to<a name="line609"></a>
 * parent node space<a name="line610"></a>
 * @param {goog.math.Coordinate} coord Local coordinate.<a name="line611"></a>
 * @return {goog.math.Coordinate} Parent coordinate.<a name="line612"></a>
 */<a name="line613"></a>
lime.Node.prototype.localToParent = function(coord) {<a name="line614"></a>
    if (!this.getParent()) return coord;<a name="line615"></a>
    var newcoord = coord.clone();<a name="line616"></a>
<a name="line617"></a>
    if (this.rotation_ != 0) {<a name="line618"></a>
        var rot = -this.rotation_ * Math.PI / 180,<a name="line619"></a>
            cos = Math.cos(rot),<a name="line620"></a>
            sin = Math.sin(rot);<a name="line621"></a>
        newcoord.x = cos * coord.x - sin * coord.y;<a name="line622"></a>
        newcoord.y = cos * coord.y + sin * coord.x;<a name="line623"></a>
    }<a name="line624"></a>
<a name="line625"></a>
    newcoord.x *= this.scale_.x;<a name="line626"></a>
    newcoord.y *= this.scale_.y;<a name="line627"></a>
<a name="line628"></a>
    newcoord.x += this.position_.x;<a name="line629"></a>
    newcoord.y += this.position_.y;<a name="line630"></a>
<a name="line631"></a>
    return newcoord;<a name="line632"></a>
};<a name="line633"></a>
<a name="line634"></a>
/**<a name="line635"></a>
 * Convert coordinate in node space to other nodes coordinate space<a name="line636"></a>
 * @param {goog.math.Coordinate} coord Local coordinate.<a name="line637"></a>
 * @param {lime.Node} node Node for new coordinate space.<a name="line638"></a>
 * @return {goog.math.Coordinate} Coordinate in node space.<a name="line639"></a>
 */<a name="line640"></a>
lime.Node.prototype.localToNode = function(coord, node) {<a name="line641"></a>
    // Todo: this can be optimized.<a name="line642"></a>
    // maybe with goog.dom.findCommonAncestor but probably even more<a name="line643"></a>
    if (!this.inTree_) return coord;<a name="line644"></a>
    return node.screenToLocal(this.localToScreen(coord));<a name="line645"></a>
<a name="line646"></a>
};<a name="line647"></a>
<a name="line648"></a>
/**<a name="line649"></a>
 * Returns the opacity value of the Node. 0.0=100% trasparent, 1.0=100% opaque<a name="line650"></a>
 * @return {number} Opacity value.<a name="line651"></a>
 */<a name="line652"></a>
lime.Node.prototype.getOpacity = function() {<a name="line653"></a>
    return this.opacity_;<a name="line654"></a>
};<a name="line655"></a>
<a name="line656"></a>
/**<a name="line657"></a>
 * Sets the opacity value of the Node object<a name="line658"></a>
 * @param {number} value New opacity value(0-1).<a name="line659"></a>
 * @return {lime.Node} The node object itself.<a name="line660"></a>
 */<a name="line661"></a>
lime.Node.prototype.setOpacity = function(value) {<a name="line662"></a>
    this.opacity_ = value;<a name="line663"></a>
<a name="line664"></a>
    var hidden = this.getHidden();<a name="line665"></a>
    if (this.opacity_ == 0 && !hidden) {<a name="line666"></a>
        this.setHidden(true);<a name="line667"></a>
        this.autoHide_ = 1;<a name="line668"></a>
    } else if (this.opacity_ != 0 && hidden && this.autoHide_) {<a name="line669"></a>
        this.setHidden(false);<a name="line670"></a>
    }<a name="line671"></a>
<a name="line672"></a>
    if (goog.isDef(this.transitionsActive_[lime.Transition.OPACITY])) {<a name="line673"></a>
        return this;<a name="line674"></a>
    }<a name="line675"></a>
<a name="line676"></a>
    this.setDirty(lime.Dirty.ALPHA);<a name="line677"></a>
    return this;<a name="line678"></a>
};<a name="line679"></a>
<a name="line680"></a>
<a name="line681"></a>
/**<a name="line682"></a>
 * Create DOM element to render the node<a name="line683"></a>
 */<a name="line684"></a>
lime.Node.prototype.createDomElement = function() {<a name="line685"></a>
<a name="line686"></a>
    var newTagName =<a name="line687"></a>
        this.renderer.getType() == lime.Renderer.CANVAS ? 'canvas' : 'div';<a name="line688"></a>
    var create = function() {<a name="line689"></a>
        this.domElement = this.rootElement =<a name="line690"></a>
            this.containerElement = goog.dom.createDom(newTagName);<a name="line691"></a>
        if (this.domClassName)<a name="line692"></a>
            goog.dom.classes.add(this.domElement, this.domClassName);<a name="line693"></a>
        this.dirty_ |= ~0;<a name="line694"></a>
    };<a name="line695"></a>
<a name="line696"></a>
    if (this.domElement) {<a name="line697"></a>
        var curtag = this.domElement.tagName.toLowerCase();<a name="line698"></a>
        if (curtag != newTagName) {<a name="line699"></a>
            var oldEl = this.rootElement;<a name="line700"></a>
            create.call(this);<a name="line701"></a>
            if (oldEl.parentNode)<a name="line702"></a>
                oldEl.parentNode.replaceChild(this.rootElement, oldEl);<a name="line703"></a>
            //return true;<a name="line704"></a>
        }<a name="line705"></a>
    } else {<a name="line706"></a>
        create.call(this);<a name="line707"></a>
        //return true;<a name="line708"></a>
    }<a name="line709"></a>
<a name="line710"></a>
};<a name="line711"></a>
<a name="line712"></a>
/**<a name="line713"></a>
 * Update DOM element connected to the node<a name="line714"></a>
 */<a name="line715"></a>
lime.Node.prototype.updateDomElement = function() {<a name="line716"></a>
    if (this.needsDomElement()) {<a name="line717"></a>
        this.createDomElement();<a name="line718"></a>
    } else {<a name="line719"></a>
        this.removeDomElement();<a name="line720"></a>
    }<a name="line721"></a>
    //return false;<a name="line722"></a>
};<a name="line723"></a>
<a name="line724"></a>
/**<a name="line725"></a>
 * Remove DOM element connected to teh node<a name="line726"></a>
 */<a name="line727"></a>
lime.Node.prototype.removeDomElement = function() {<a name="line728"></a>
    if (this.rootElement) {<a name="line729"></a>
        goog.dom.removeNode(this.rootElement);<a name="line730"></a>
        delete this.domElement;<a name="line731"></a>
        delete this.rootElement;<a name="line732"></a>
        delete this.containerElement;<a name="line733"></a>
        //return true;<a name="line734"></a>
    }<a name="line735"></a>
};<a name="line736"></a>
<a name="line737"></a>
/**<a name="line738"></a>
 * Update node's layout (tree relations)<a name="line739"></a>
 */<a name="line740"></a>
lime.Node.prototype.updateLayout = function() {<a name="line741"></a>
    // debugger;<a name="line742"></a>
    this.dirty_ &= ~lime.Dirty.LAYOUT;<a name="line743"></a>
    //var didupdate = this.updateDomElement();<a name="line744"></a>
    this.updateDomElement();<a name="line745"></a>
<a name="line746"></a>
    if (this.parent_ && (this.parent_.dirty_ & lime.Dirty.LAYOUT)) {<a name="line747"></a>
        this.parent_.updateLayout();<a name="line748"></a>
        return;<a name="line749"></a>
    }<a name="line750"></a>
<a name="line751"></a>
    if (this.needsDomElement()) {<a name="line752"></a>
<a name="line753"></a>
        for (var i = 0, child; child = this.children_[i]; i++) {<a name="line754"></a>
            if (child instanceof lime.Node)<a name="line755"></a>
                child.updateLayout();<a name="line756"></a>
        }<a name="line757"></a>
<a name="line758"></a>
        this.renderer.updateLayout.call(this);<a name="line759"></a>
<a name="line760"></a>
    }<a name="line761"></a>
<a name="line762"></a>
};<a name="line763"></a>
<a name="line764"></a>
/**<a name="line765"></a>
 * Update modified dirty parameters to visible elements properties<a name="line766"></a>
 * @param {number=} opt_pass Pass number.<a name="line767"></a>
 */<a name="line768"></a>
lime.Node.prototype.update = function(opt_pass) {<a name="line769"></a>
    // if (!this.renderer) return;<a name="line770"></a>
    var property,<a name="line771"></a>
        value;<a name="line772"></a>
    var pass = opt_pass || 0;<a name="line773"></a>
<a name="line774"></a>
    var uid = goog.getUid(this);<a name="line775"></a>
    if (this.dirty_ & lime.Dirty.LAYOUT) {<a name="line776"></a>
        this.updateLayout();<a name="line777"></a>
    }<a name="line778"></a>
<a name="line779"></a>
    var do_draw = this.renderer.getType() == lime.Renderer.DOM || pass;<a name="line780"></a>
<a name="line781"></a>
    if (do_draw) {<a name="line782"></a>
<a name="line783"></a>
        //clear transitions in the queue<a name="line784"></a>
        for (var i in this.transitionsClear_) {<a name="line785"></a>
            delete this.transitionsActive_[i];<a name="line786"></a>
            delete this.transitionsActiveSet_[i];<a name="line787"></a>
            property = lime.Node.getPropertyForTransition(parseInt(i, 10));<a name="line788"></a>
            lime.style.clearTransition(this.domElement, property);<a name="line789"></a>
            if (this.domElement != this.containerElement) {<a name="line790"></a>
                lime.style.clearTransition(this.continerElement, property);<a name="line791"></a>
            }<a name="line792"></a>
        }<a name="line793"></a>
<a name="line794"></a>
        // predraw is a check that elements are correctly drawn before the<a name="line795"></a>
        // transition. if not then transition is started in the next frame not now.<a name="line796"></a>
        var only_predraw = 0;<a name="line797"></a>
        for (i in this.transitionsAdd_) {<a name="line798"></a>
            value = this.transitionsAdd_[i];<a name="line799"></a>
<a name="line800"></a>
            // 3rd is an "already_activated" flag<a name="line801"></a>
            if (!value[3]) {<a name="line802"></a>
                value[3] = 1;<a name="line803"></a>
<a name="line804"></a>
                if (i == lime.Transition.POSITION &&<a name="line805"></a>
                    this.positionDrawn_ != this.position_) {<a name="line806"></a>
                    this.setDirty(lime.Dirty.POSITION, 0, true);<a name="line807"></a>
                    only_predraw = 1;<a name="line808"></a>
                }<a name="line809"></a>
<a name="line810"></a>
                if (i == lime.Transition.SCALE &&<a name="line811"></a>
                    this.scaleDrawn_ != this.scale_) {<a name="line812"></a>
                    this.setDirty(lime.Dirty.SCALE, 0, true);<a name="line813"></a>
                    only_predraw = 1;<a name="line814"></a>
                }<a name="line815"></a>
<a name="line816"></a>
                if (i == lime.Transition.OPACITY &&<a name="line817"></a>
                    this.opacityDrawn_ != this.opacity_) {<a name="line818"></a>
                    this.setDirty(lime.Dirty.ALPHA, 0, true);<a name="line819"></a>
                    only_predraw = 1;<a name="line820"></a>
                }<a name="line821"></a>
                if (i == lime.Transition.ROTATION &&<a name="line822"></a>
                    this.rotationDrawn_ != this.rotation_) {<a name="line823"></a>
                    this.setDirty(lime.Dirty.ROTATION, 0, true);<a name="line824"></a>
                    only_predraw = 1;<a name="line825"></a>
                }<a name="line826"></a>
<a name="line827"></a>
            }<a name="line828"></a>
        }<a name="line829"></a>
<a name="line830"></a>
        // activate the transitions<a name="line831"></a>
        if (!only_predraw)<a name="line832"></a>
            for (i in this.transitionsAdd_) {<a name="line833"></a>
                value = this.transitionsAdd_[i];<a name="line834"></a>
                property = lime.Node.getPropertyForTransition(parseInt(i, 10));<a name="line835"></a>
<a name="line836"></a>
                if (this.renderer.getType() == lime.Renderer.DOM || property != 'opacity') {<a name="line837"></a>
<a name="line838"></a>
                    this.transitionsActive_[i] = value[0];<a name="line839"></a>
                    lime.style.setTransition(this.domElement,<a name="line840"></a>
                        property, value[1], value[2]);<a name="line841"></a>
<a name="line842"></a>
                    if (this.domElement != this.containerElement &&<a name="line843"></a>
                        property == lime.style.transformProperty) {<a name="line844"></a>
<a name="line845"></a>
                        lime.style.setTransition(this.containerElement,<a name="line846"></a>
                            property, value[1], value[2]);<a name="line847"></a>
<a name="line848"></a>
                    }<a name="line849"></a>
                }<a name="line850"></a>
                delete this.transitionsAdd_[i];<a name="line851"></a>
        }<a name="line852"></a>
<a name="line853"></a>
        // cache last drawn values to for predraw check<a name="line854"></a>
        this.positionDrawn_ = this.position_;<a name="line855"></a>
        this.scaleDrawn_ = this.scale_;<a name="line856"></a>
        this.opacityDrawn_ = this.opacity_;<a name="line857"></a>
        this.rotationDrawn_ = this.rotation_;<a name="line858"></a>
<a name="line859"></a>
<a name="line860"></a>
        this.transitionsClear_ = {};<a name="line861"></a>
<a name="line862"></a>
    }<a name="line863"></a>
<a name="line864"></a>
<a name="line865"></a>
    if (pass) {<a name="line866"></a>
        this.renderer.drawCanvas.call(this);<a name="line867"></a>
    } else {<a name="line868"></a>
        if (this.renderer.getType() == lime.Renderer.CANVAS) {<a name="line869"></a>
            var parent = this.getDeepestParentWithDom();<a name="line870"></a>
            parent.redraw_ = 1;<a name="line871"></a>
            if (parent == this && this.dirty_ == lime.Dirty.POSITION && !this.mask_) {<a name="line872"></a>
                parent.redraw_ = 0;<a name="line873"></a>
            }<a name="line874"></a>
            lime.setObjectDirty(this.getDeepestParentWithDom(), 1);<a name="line875"></a>
        }<a name="line876"></a>
<a name="line877"></a>
        // dom draw happens here<a name="line878"></a>
        this.renderer.update.call(this);<a name="line879"></a>
<a name="line880"></a>
    }<a name="line881"></a>
<a name="line882"></a>
    // set flags that transitions have been draw.<a name="line883"></a>
    if (do_draw)<a name="line884"></a>
        for (i in this.transitionsActive_) {<a name="line885"></a>
            if (this.transitionsActive_[i]) {<a name="line886"></a>
                this.transitionsActiveSet_[i] = true;<a name="line887"></a>
            }<a name="line888"></a>
    }<a name="line889"></a>
<a name="line890"></a>
    if (this.dependencies_) {<a name="line891"></a>
        for (var i = 0; i &lt; this.dependencies_.length; i++) {<a name="line892"></a>
            this.dependencies_[i].setDirty(lime.Dirty.ALL);<a name="line893"></a>
        }<a name="line894"></a>
    }<a name="line895"></a>
<a name="line896"></a>
    //clear dirty<a name="line897"></a>
    this.setDirty(0, pass);<a name="line898"></a>
<a name="line899"></a>
};<a name="line900"></a>
<a name="line901"></a>
/**<a name="line902"></a>
 * Return CSS property name for transition constant<a name="line903"></a>
 * @param {number} transition Transition constant.<a name="line904"></a>
 * @return {string} Property name.<a name="line905"></a>
 */<a name="line906"></a>
lime.Node.getPropertyForTransition = function(transition) {<a name="line907"></a>
    return transition == lime.Transition.OPACITY ?<a name="line908"></a>
        'opacity' : lime.style.transformProperty;<a name="line909"></a>
};<a name="line910"></a>
<a name="line911"></a>
<a name="line912"></a>
/**<a name="line913"></a>
 * Return the parent object. Returns null in not in tree<a name="line914"></a>
 * @return {lime.Node} Parent node.<a name="line915"></a>
 */<a name="line916"></a>
lime.Node.prototype.getParent = function() {<a name="line917"></a>
    return this.parent_ ? this.parent_ : null;<a name="line918"></a>
};<a name="line919"></a>
<a name="line920"></a>
/**<a name="line921"></a>
 * Append element to the end of childrens array<a name="line922"></a>
 * @param {lime.Node|Element|Node} child Child node.<a name="line923"></a>
 * @param {number=} opt_pos Position of new child.<a name="line924"></a>
 * @return {lime.Node} obejct itself.<a name="line925"></a>
 */<a name="line926"></a>
lime.Node.prototype.appendChild = function(child, opt_pos) {<a name="line927"></a>
<a name="line928"></a>
    if (child instanceof lime.Node && child.getParent()) {<a name="line929"></a>
        child.getParent().removeChild(child);<a name="line930"></a>
    } else if (child.parentNode) {<a name="line931"></a>
        goog.dom.removeNode( /** @type {Node} */ (child));<a name="line932"></a>
    }<a name="line933"></a>
<a name="line934"></a>
    child.parent_ = this;<a name="line935"></a>
<a name="line936"></a>
    if (opt_pos == undefined) {<a name="line937"></a>
        this.children_.push(child);<a name="line938"></a>
    } else {<a name="line939"></a>
        goog.array.insertAt(this.children_, child, opt_pos);<a name="line940"></a>
    }<a name="line941"></a>
    if (this.renderer.getType() != lime.Renderer.DOM) {<a name="line942"></a>
<a name="line943"></a>
        child.setRenderer(this.renderer.getType());<a name="line944"></a>
    }<a name="line945"></a>
    if (child instanceof lime.Node) {<a name="line946"></a>
        child.calcRelativeQuality();<a name="line947"></a>
        if (this.inTree_) child.wasAddedToTree();<a name="line948"></a>
    }<a name="line949"></a>
    return this.setDirty(lime.Dirty.LAYOUT);<a name="line950"></a>
};<a name="line951"></a>
<a name="line952"></a>
/**<a name="line953"></a>
 * Return number of childnodes current element has.<a name="line954"></a>
 * @return {number} Number of children.<a name="line955"></a>
 */<a name="line956"></a>
lime.Node.prototype.getNumberOfChildren = function() {<a name="line957"></a>
    return this.children_.length;<a name="line958"></a>
}<a name="line959"></a>
<a name="line960"></a>
/**<a name="line961"></a>
 * Return the child at defined index.<a name="line962"></a>
 * @param {number} index Child index.<a name="line963"></a>
 * @return {lime.Node|Element|null} Child element.<a name="line964"></a>
 */<a name="line965"></a>
lime.Node.prototype.getChildAt = function(index) {<a name="line966"></a>
    if (index >= 0 && this.getNumberOfChildren() > index) {<a name="line967"></a>
        return this.children_[index];<a name="line968"></a>
    } else {<a name="line969"></a>
        return null;<a name="line970"></a>
    }<a name="line971"></a>
};<a name="line972"></a>
<a name="line973"></a>
/**<a name="line974"></a>
 * Return the index position of a child.<a name="line975"></a>
 * @param {lime.Node|Element} child Child to search.<a name="line976"></a>
 * @return {number} Index number.<a name="line977"></a>
 */<a name="line978"></a>
lime.Node.prototype.getChildIndex = function(child) {<a name="line979"></a>
    return this.children_.indexOf(child);<a name="line980"></a>
};<a name="line981"></a>
<a name="line982"></a>
/**<a name="line983"></a>
 * Remove element from the childrens array<a name="line984"></a>
 * @param {lime.Node|Element} child Child node.<a name="line985"></a>
 * @return {lime.Node} object itself.<a name="line986"></a>
 */<a name="line987"></a>
lime.Node.prototype.removeChild = function(child) {<a name="line988"></a>
    return this.removeChildAt(this.getChildIndex(child));<a name="line989"></a>
};<a name="line990"></a>
<a name="line991"></a>
/**<a name="line992"></a>
 * Remove element at a given index from the childrens array<a name="line993"></a>
 * @param {number} index Index of element to remove.<a name="line994"></a>
 * @return {lime.Node} object itself.<a name="line995"></a>
 */<a name="line996"></a>
lime.Node.prototype.removeChildAt = function(index) {<a name="line997"></a>
    if (index >= 0 && this.getNumberOfChildren() > index) {<a name="line998"></a>
        var child = this.getChildAt(index);<a name="line999"></a>
        if (child.maskTarget_) {<a name="line1000"></a>
            child.maskTarget_.setMask(null);<a name="line1001"></a>
        }<a name="line1002"></a>
        if (child instanceof lime.Node) {<a name="line1003"></a>
            if (this.inTree_)<a name="line1004"></a>
                child.wasRemovedFromTree();<a name="line1005"></a>
            child.removeDomElement();<a name="line1006"></a>
            child.parent_ = null;<a name="line1007"></a>
        } else<a name="line1008"></a>
            goog.dom.removeNode(child);<a name="line1009"></a>
<a name="line1010"></a>
        this.children_.splice(index, 1);<a name="line1011"></a>
        return this.setDirty(lime.Dirty.LAYOUT);<a name="line1012"></a>
    }<a name="line1013"></a>
    return this;<a name="line1014"></a>
};<a name="line1015"></a>
<a name="line1016"></a>
/**<a name="line1017"></a>
 * Removes all children of a node.<a name="line1018"></a>
 * @return {lime.Node} object itself.<a name="line1019"></a>
 */<a name="line1020"></a>
lime.Node.prototype.removeAllChildren = function() {<a name="line1021"></a>
    while (this.getNumberOfChildren()) {<a name="line1022"></a>
        this.removeChildAt(0);<a name="line1023"></a>
    }<a name="line1024"></a>
    return this;<a name="line1025"></a>
};<a name="line1026"></a>
<a name="line1027"></a>
/**<a name="line1028"></a>
 * Move a child to another index in the childrens array.<a name="line1029"></a>
 * @param {lime.Node} child Child node.<a name="line1030"></a>
 * @param {number} index New index for the child.<a name="line1031"></a>
 * @return {lime.Node} object itself.<a name="line1032"></a>
 */<a name="line1033"></a>
lime.Node.prototype.setChildIndex = function(child, index) {<a name="line1034"></a>
    var oldindex = this.getChildIndex(child);<a name="line1035"></a>
    if (oldindex != -1 && oldindex != index) {<a name="line1036"></a>
        this.children_.splice(oldindex, 1);<a name="line1037"></a>
        goog.array.insertAt(this.children_, child, index);<a name="line1038"></a>
        if (this.getDirector())<a name="line1039"></a>
            this.getDirector().eventDispatcher.updateDispatchOrder(child);<a name="line1040"></a>
        return this.setDirty(lime.Dirty.LAYOUT);<a name="line1041"></a>
    }<a name="line1042"></a>
    return this;<a name="line1043"></a>
};<a name="line1044"></a>
<a name="line1045"></a>
/**<a name="line1046"></a>
 * @inheritDoc<a name="line1047"></a>
 */<a name="line1048"></a>
lime.Node.prototype.addEventListener = function(type, handler,<a name="line1049"></a>
    opt_capture, opt_handlerScope) {<a name="line1050"></a>
<a name="line1051"></a>
    // Bypass all mouse events on touchscreen devices<a name="line1052"></a>
    if (lime.userAgent.SUPPORTS_TOUCH &&<a name="line1053"></a>
        type.substring(0, 5) == 'mouse') return;<a name="line1054"></a>
<a name="line1055"></a>
    // First element defines if events are registered with DOM 1=yes/0=no<a name="line1056"></a>
    // Second element defines how many listeners have been set<a name="line1057"></a>
    if (!goog.isDef(this.eventHandlers_[type])) {<a name="line1058"></a>
        this.eventHandlers_[type] = [0, 0];<a name="line1059"></a>
    }<a name="line1060"></a>
<a name="line1061"></a>
    if (this.inTree_ && this.eventHandlers_[type][0] == 0) {<a name="line1062"></a>
        this.eventHandlers_[type][0] = 1;<a name="line1063"></a>
        this.getDirector().eventDispatcher.register(this, type);<a name="line1064"></a>
    }<a name="line1065"></a>
    this.eventHandlers_[type][1]++;<a name="line1066"></a>
<a name="line1067"></a>
};<a name="line1068"></a>
<a name="line1069"></a>
/**<a name="line1070"></a>
 * @inheritDoc<a name="line1071"></a>
 */<a name="line1072"></a>
lime.Node.prototype.removeEventListener = function(<a name="line1073"></a>
    type, handler, opt_capture, opt_handlerScope) {<a name="line1074"></a>
<a name="line1075"></a>
    // Bypass all mouse events on touchscreen devices<a name="line1076"></a>
    if (lime.userAgent.SUPPORTS_TOUCH &&<a name="line1077"></a>
        type.substring(0, 5) == 'mouse') return;<a name="line1078"></a>
<a name="line1079"></a>
    if (this.inTree_ && this.eventHandlers_[type][1] == 1) {<a name="line1080"></a>
        this.eventHandlers_[type][0] = 0;<a name="line1081"></a>
        this.getDirector().eventDispatcher.release(this, type);<a name="line1082"></a>
    }<a name="line1083"></a>
    this.eventHandlers_[type][1]--;<a name="line1084"></a>
    if (!this.eventHandlers_[type][1]) delete this.eventHandlers_[type];<a name="line1085"></a>
<a name="line1086"></a>
};<a name="line1087"></a>
<a name="line1088"></a>
/**<a name="line1089"></a>
 * Return the Director instance related to the node.<a name="line1090"></a>
 * Returns null if no director connection.<a name="line1091"></a>
 * @return {lime.Director} Current director.<a name="line1092"></a>
 */<a name="line1093"></a>
lime.Node.prototype.getDirector = function() {<a name="line1094"></a>
    if (!this.inTree_) return null;<a name="line1095"></a>
<a name="line1096"></a>
    return this.director_;<a name="line1097"></a>
};<a name="line1098"></a>
<a name="line1099"></a>
/**<a name="line1100"></a>
 * Returns the Scene instance related to the node.<a name="line1101"></a>
 * Returns null if no scene connection.<a name="line1102"></a>
 * @return {lime.Scene} Current scene.<a name="line1103"></a>
 */<a name="line1104"></a>
lime.Node.prototype.getScene = function() {<a name="line1105"></a>
    if (!this.inTree_) return null;<a name="line1106"></a>
<a name="line1107"></a>
    return this.scene_;<a name="line1108"></a>
};<a name="line1109"></a>
<a name="line1110"></a>
/**<a name="line1111"></a>
 * Handle removing Node from DOM tree<a name="line1112"></a>
 */<a name="line1113"></a>
lime.Node.prototype.wasRemovedFromTree = function() {<a name="line1114"></a>
    var child;<a name="line1115"></a>
<a name="line1116"></a>
    if (!this.dependencySet_) {<a name="line1117"></a>
        this.removeDependency(this.getParent());<a name="line1118"></a>
    }<a name="line1119"></a>
<a name="line1120"></a>
    // Call remove for all children<a name="line1121"></a>
    for (var i = 0; child = this.children_[i]; i++) {<a name="line1122"></a>
        if (child instanceof lime.Node) {<a name="line1123"></a>
            child.wasRemovedFromTree();<a name="line1124"></a>
        }<a name="line1125"></a>
    }<a name="line1126"></a>
    // Unregister Event listeners<a name="line1127"></a>
    for (var type in this.eventHandlers_) {<a name="line1128"></a>
        this.eventHandlers_[type][0] = 0;<a name="line1129"></a>
<a name="line1130"></a>
        if (!this.getDirector()) debugger;<a name="line1131"></a>
        this.getDirector().eventDispatcher.release(this, type);<a name="line1132"></a>
    }<a name="line1133"></a>
<a name="line1134"></a>
    this.getDirector().eventDispatcher.updateDispatchOrder(this);<a name="line1135"></a>
<a name="line1136"></a>
    this.inTree_ = false;<a name="line1137"></a>
    this.director_ = null;<a name="line1138"></a>
    this.scene_ = null;<a name="line1139"></a>
<a name="line1140"></a>
};<a name="line1141"></a>
<a name="line1142"></a>
/**<a name="line1143"></a>
 * Handle adding Node to the DOM tree<a name="line1144"></a>
 */<a name="line1145"></a>
lime.Node.prototype.wasAddedToTree = function() {<a name="line1146"></a>
    this.inTree_ = true;<a name="line1147"></a>
    this.director_ = this.parent_.getDirector();<a name="line1148"></a>
    this.scene_ = this.parent_.getScene();<a name="line1149"></a>
<a name="line1150"></a>
    // Notify all children<a name="line1151"></a>
    for (var i = 0, child; child = this.children_[i]; i++) {<a name="line1152"></a>
        if (child instanceof lime.Node) {<a name="line1153"></a>
            child.wasAddedToTree();<a name="line1154"></a>
        }<a name="line1155"></a>
    }<a name="line1156"></a>
    // Register Event Listeners<a name="line1157"></a>
    for (var type in this.eventHandlers_) {<a name="line1158"></a>
        this.eventHandlers_[type][0] = 1;<a name="line1159"></a>
        this.getDirector().eventDispatcher.register(this, type);<a name="line1160"></a>
    }<a name="line1161"></a>
<a name="line1162"></a>
    if (this.dependencySet_) {<a name="line1163"></a>
        this.setupDependencies();<a name="line1164"></a>
    }<a name="line1165"></a>
    this.getDirector().eventDispatcher.updateDispatchOrder(this);<a name="line1166"></a>
};<a name="line1167"></a>
<a name="line1168"></a>
lime.Node.prototype.setupDependencies = function() {<a name="line1169"></a>
    this.dependencySet_ = true;<a name="line1170"></a>
    if (this.inTree_) {<a name="line1171"></a>
        this.addDependency(this.getParent());<a name="line1172"></a>
    }<a name="line1173"></a>
}<a name="line1174"></a>
<a name="line1175"></a>
lime.Node.prototype.addDependency = function(other) {<a name="line1176"></a>
    if (!other.dependencies_) other.dependencies_ = [];<a name="line1177"></a>
<a name="line1178"></a>
    goog.array.insert(other.dependencies_, this);<a name="line1179"></a>
    if (!other && !(other.getParent() instanceof lime.Scene)) {<a name="line1180"></a>
        this.addDependency(other.getParent());<a name="line1181"></a>
    }<a name="line1182"></a>
<a name="line1183"></a>
}<a name="line1184"></a>
<a name="line1185"></a>
lime.Node.prototype.removeDependency = function(other) {<a name="line1186"></a>
    if (!other || !other.dependencies_) return;<a name="line1187"></a>
<a name="line1188"></a>
    goog.array.remove(other.dependencies_, this);<a name="line1189"></a>
    this.removeDependency(other.getParent());<a name="line1190"></a>
}<a name="line1191"></a>
<a name="line1192"></a>
lime.Node.prototype.releaseDependencies = function() {<a name="line1193"></a>
    delete this.dependencySet_;<a name="line1194"></a>
    this.removeDependency(this.getParent());<a name="line1195"></a>
}<a name="line1196"></a>
<a name="line1197"></a>
/**<a name="line1198"></a>
 * Returns a bounding box for the element in its own coordinate space<a name="line1199"></a>
 * @return {goog.math.Box} Contents frame in node space.<a name="line1200"></a>
 */<a name="line1201"></a>
lime.Node.prototype.getFrame = function() {<a name="line1202"></a>
    var s = this.getSize(),<a name="line1203"></a>
        a = this.getAnchorPoint();<a name="line1204"></a>
<a name="line1205"></a>
    return new goog.math.Box(-s.height * a.y, //top<a name="line1206"></a>
    s.width * (1 - a.x), //right<a name="line1207"></a>
    s.height * (1 - a.y), //bottom<a name="line1208"></a>
    -s.width * a.x //left<a name="line1209"></a>
    );<a name="line1210"></a>
};<a name="line1211"></a>
<a name="line1212"></a>
/**<a name="line1213"></a>
 * Returns bounding box for element in parents coordinate space.<a name="line1214"></a>
 * @param {goog.math.Box} opt_frame Optional frame box for element.<a name="line1215"></a>
 * @return {goog.math.Box} Bounding box.<a name="line1216"></a>
 */<a name="line1217"></a>
lime.Node.prototype.getBoundingBox = function(opt_frame) {<a name="line1218"></a>
    var frame = opt_frame || this.getFrame();<a name="line1219"></a>
    var tl = new goog.math.Coordinate(frame.left, frame.top);<a name="line1220"></a>
    var tr = new goog.math.Coordinate(frame.right, frame.top);<a name="line1221"></a>
    var bl = new goog.math.Coordinate(frame.left, frame.bottom);<a name="line1222"></a>
    var br = new goog.math.Coordinate(frame.right, frame.bottom);<a name="line1223"></a>
<a name="line1224"></a>
    tl = this.localToParent(tl);<a name="line1225"></a>
    tr = this.localToParent(tr);<a name="line1226"></a>
    bl = this.localToParent(bl);<a name="line1227"></a>
    br = this.localToParent(br);<a name="line1228"></a>
<a name="line1229"></a>
    return new goog.math.Box(<a name="line1230"></a>
        Math.floor(Math.min(tl.y, tr.y, bl.y, br.y)),<a name="line1231"></a>
        Math.ceil(Math.max(tl.x, tr.x, bl.x, br.x)),<a name="line1232"></a>
        Math.ceil(Math.max(tl.y, tr.y, bl.y, br.y)),<a name="line1233"></a>
        Math.floor(Math.min(tl.x, tr.x, bl.x, br.x)));<a name="line1234"></a>
<a name="line1235"></a>
};<a name="line1236"></a>
<a name="line1237"></a>
/**<a name="line1238"></a>
 * Return box containing current element and all its children<a name="line1239"></a>
 * @return {goog.math.Box} Bounding box.<a name="line1240"></a>
 */<a name="line1241"></a>
lime.Node.prototype.measureContents = function() {<a name="line1242"></a>
<a name="line1243"></a>
    var frame = this.getFrame();<a name="line1244"></a>
    if (frame.left == frame.right && this.children_.length) {<a name="line1245"></a>
        frame = this.children_[0].getBoundingBox(<a name="line1246"></a>
            this.children_[0].measureContents());<a name="line1247"></a>
    }<a name="line1248"></a>
<a name="line1249"></a>
<a name="line1250"></a>
    for (var i = 0, child; child = this.children_[i]; i++) {<a name="line1251"></a>
        if (child.isMask != 1)<a name="line1252"></a>
            frame.expandToInclude(child.getBoundingBox(child.measureContents()));<a name="line1253"></a>
    }<a name="line1254"></a>
<a name="line1255"></a>
    return frame;<a name="line1256"></a>
<a name="line1257"></a>
};<a name="line1258"></a>
<a name="line1259"></a>
/**<a name="line1260"></a>
 * Register transition property. Use through animations.<a name="line1261"></a>
 * @param {number} property Transition property constant.<a name="line1262"></a>
 * @param {*} value New value.<a name="line1263"></a>
 * @param {number} duration Transition duration.<a name="line1264"></a>
 * @param {Array.&lt;*>} ease Easing function.<a name="line1265"></a>
 */<a name="line1266"></a>
lime.Node.prototype.addTransition = function(property, value, duration, ease) {<a name="line1267"></a>
    this.transitionsAdd_[property] = [value, duration, ease, 0];<a name="line1268"></a>
};<a name="line1269"></a>
<a name="line1270"></a>
/**<a name="line1271"></a>
 * Clear previously set transition<a name="line1272"></a>
 * @param {number} property Transition property.<a name="line1273"></a>
 */<a name="line1274"></a>
lime.Node.prototype.clearTransition = function(property) {<a name="line1275"></a>
    this.transitionsClear_[property] = 1;<a name="line1276"></a>
};<a name="line1277"></a>
<a name="line1278"></a>
/**<a name="line1279"></a>
 * Checks if event should fire on element based on the position.<a name="line1280"></a>
 * Before returning true this function should set the position property<a name="line1281"></a>
 * of the event to the hit position in elements coordinate space<a name="line1282"></a>
 * @param {lime.events.Event} e Event object.<a name="line1283"></a>
 * @return {boolean} If node should handle the event.<a name="line1284"></a>
 */<a name="line1285"></a>
lime.Node.prototype.hitTest = function(e) {<a name="line1286"></a>
    var coord = this.screenToLocal(e.screenPosition);<a name="line1287"></a>
    if (this.getFrame().contains(coord)) {<a name="line1288"></a>
        e.position = coord;<a name="line1289"></a>
        return true;<a name="line1290"></a>
    }<a name="line1291"></a>
    return false;<a name="line1292"></a>
};<a name="line1293"></a>
<a name="line1294"></a>
/**<a name="line1295"></a>
 * Add Node to action targets list and start the animation<a name="line1296"></a>
 * @param {lime.animation.Animation} action Animation to run.<a name="line1297"></a>
 */<a name="line1298"></a>
lime.Node.prototype.runAction = function(action) {<a name="line1299"></a>
    action.addTarget(this);<a name="line1300"></a>
    action.play();<a name="line1301"></a>
};<a name="line1302"></a></code></pre>
			<a name="line"></a>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Classes</h3><ul><li><a href="lime.animation.actionManager.html">actionManager</a></li><li><a href="lime.animation.Animation.html">Animation</a></li><li><a href="lime.animation.ColorTo.html">ColorTo</a></li><li><a href="lime.animation.Delay.html">Delay</a></li><li><a href="lime.animation.FadeTo.html">FadeTo</a></li><li><a href="lime.animation.KeyframeAnimation.html">KeyframeAnimation</a></li><li><a href="lime.animation.Loop.html">Loop</a></li><li><a href="lime.animation.MoveBy.html">MoveBy</a></li><li><a href="lime.animation.MoveTo.html">MoveTo</a></li><li><a href="lime.animation.Resize.html">Resize</a></li><li><a href="lime.animation.RotateBy.html">RotateBy</a></li><li><a href="lime.animation.RotateTo.html">RotateTo</a></li><li><a href="lime.animation.ScaleBy.html">ScaleBy</a></li><li><a href="lime.animation.ScaleTo.html">ScaleTo</a></li><li><a href="lime.animation.Sequence.html">Sequence</a></li><li><a href="lime.animation.Spawn.html">Spawn</a></li><li><a href="lime.audio.Audio.html">Audio</a></li><li><a href="lime.audio.AudioMap.html">AudioMap</a></li><li><a href="lime.Button.html">Button</a></li><li><a href="lime.CanvasContext.html">CanvasContext</a></li><li><a href="lime.Circle.html">Circle</a></li><li><a href="lime.CoverNode.html">CoverNode</a></li><li><a href="lime.Director.html">Director</a></li><li><a href="lime.events.Drag.html">Drag</a></li><li><a href="lime.events.Event.html">Event</a></li><li><a href="lime.events.EventDispatcher.html">EventDispatcher</a></li><li><a href="lime.fill.Color.html">Color</a></li><li><a href="lime.fill.Fill.html">Fill</a></li><li><a href="lime.fill.Frame.html">Frame</a></li><li><a href="lime.fill.Image.html">Image</a></li><li><a href="lime.fill.LinearGradient.html">LinearGradient</a></li><li><a href="lime.fill.Stroke.html">Stroke</a></li><li><a href="lime.GlossyButton.html">GlossyButton</a></li><li><a href="lime.helper.PauseScene.html">PauseScene</a></li><li><a href="lime.Label.html">Label</a></li><li><a href="lime.Layer.html">Layer</a></li><li><a href="lime.Node.html">Node</a></li><li><a href="lime.Polygon.html">Polygon</a></li><li><a href="lime.Renderer.html">Renderer</a></li><li><a href="lime.RoundedRect.html">RoundedRect</a></li><li><a href="lime.Scene.html">Scene</a></li><li><a href="lime.scheduleManager.html">scheduleManager</a></li><li><a href="lime.scheduleManager.Task.html">Task</a></li><li><a href="lime.Sprite.html">Sprite</a></li><li><a href="lime.SpriteSheet.html">SpriteSheet</a></li><li><a href="lime.style.Transform.html">Transform</a></li><li><a href="lime.transitions.Dissolve.html">Dissolve</a></li><li><a href="lime.transitions.MoveInDown.html">MoveInDown</a></li><li><a href="lime.transitions.MoveInLeft.html">MoveInLeft</a></li><li><a href="lime.transitions.MoveInRight.html">MoveInRight</a></li><li><a href="lime.transitions.MoveInUp.html">MoveInUp</a></li><li><a href="lime.transitions.SlideIn.html">SlideIn</a></li><li><a href="lime.transitions.SlideInDown.html">SlideInDown</a></li><li><a href="lime.transitions.SlideInRight.html">SlideInRight</a></li><li><a href="lime.transitions.SlideInUp.html">SlideInUp</a></li><li><a href="lime.transitions.Transition.html">Transition</a></li><li><a href="lime.ui.Container.html">Container</a></li><li><a href="lime.ui.Scroller.html">Scroller</a></li><li><a href="soy.$$augmentMap-TempCtor.html">TempCtor</a></li><li><a href="soy.StringBuilder.html">StringBuilder</a></li><li><a href="soydata.$$makeSanitizedContentFactory_-InstantiableCtor.html">InstantiableCtor</a></li><li><a href="soydata.SanitizedCss.html">SanitizedCss</a></li><li><a href="soydata.SanitizedHtml.html">SanitizedHtml</a></li><li><a href="soydata.SanitizedHtmlAttribute.html">SanitizedHtmlAttribute</a></li><li><a href="soydata.SanitizedJs.html">SanitizedJs</a></li><li><a href="soydata.SanitizedJsStrChars.html">SanitizedJsStrChars</a></li><li><a href="soydata.SanitizedUri.html">SanitizedUri</a></li><li><a href="soydata.UnsanitizedText.html">UnsanitizedText</a></li></ul><h3>Global</h3><ul><li><a href="global.html#active_">active_</a></li><li><a href="global.html#displayRate_">displayRate_</a></li><li><a href="global.html#intervalID_">intervalID_</a></li><li><a href="global.html#lastRunTime_">lastRunTime_</a></li><li><a href="global.html#taskStack_">taskStack_</a></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.2.0-dev</a> on Tue May 28 2013 22:48:27 GMT+0200 (SAST)
</footer>

<script> prettyPrint(); </script>
</body>
</html>
